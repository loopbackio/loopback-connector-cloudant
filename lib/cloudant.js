// Copyright IBM Corp. 2015,2019. All Rights Reserved.
// Node module: loopback-connector-cloudant
// This file is licensed under the Artistic License 2.0.
// License text available at https://opensource.org/licenses/Artistic-2.0

'use strict';

const g = require('strong-globalize')();
const CouchDB = require('loopback-connector-couchdb2').CouchDB;
const Driver = require('@cloudant/cloudant');
const assert = require('assert');
const debug = require('debug')('loopback:connector:cloudant');
const async = require('async');
const url = require('url');
const util = require('util');
const _ = require('lodash');

/**
 * Initialize the Cloudant connector for the given data source
 *
 * @param {DataSource} ds The data source instance
 * @param {Function} [cb] The cb function
 */
exports.initialize = function(ds, cb) {
  ds.connector = new Cloudant(ds.settings, ds);
  if (cb) {
    if (ds.settings.lazyConnect) {
      process.nextTick(function() {
        cb();
      });
    } else {
      ds.connector.connect(cb);
    }
  }
};

/**
 * The constructor for the Cloudant LoopBack connector
 *
 * @param {Object} settings The settings object
 * @param {DataSource} ds The data source instance
 * @constructor
 */
function Cloudant(settings, ds) {
  // Injection for tests
  this.CloudantDriver = settings.Driver || Driver;
  debug('Cloudant constructor settings: %j', settings);
  CouchDB.call(this, 'cloudant', settings);
  this.debug = settings.debug || debug.enabled;
  this.dataSource = ds;
  if (!settings.url && (!settings.username || !settings.password)) {
    throw new Error(g.f('Invalid settings: "url" OR "username"' +
    ' AND "password" required'));
  }
  this.options = _.merge({}, settings);
  // If settings.url is not set, then setup account/password props.
  if (!this.options.url) {
    this.options.account = settings.username;
    this.options.password = settings.password;
  }
  this.pool = {};
}

util.inherits(Cloudant, CouchDB);

Cloudant.prototype.getTypes = function() {
  return ['db', 'nosql', 'cloudant'];
};

/**
 * Connect to Cloudant
 *
 * @param {Function} [cb] The cb function
 */
Cloudant.prototype.connect = function(cb) {
  debug('Cloudant.prototype.connect');
  const self = this;
  // strip db name if defined in path of url before
  // sending it to our driver
  if (self.options.url) {
    const parsedUrl = url.parse(self.options.url);
    if (parsedUrl.path && parsedUrl.path !== '/') {
      self.options.url = self.options.url.replace(parsedUrl.path, '');
      if (!self.options.database)
        self.options.database = parsedUrl.path.split('/')[1];
    }
  }
  self.CloudantDriver(self.options, function(err, nano) {
    if (err) return cb(err);
    self.cloudant = nano;
    if (self.options.database) {
      // check if database exists
      self.cloudant.db.get(self.options.database, function(err) {
        if (err) return cb(err);
        return cb(err, self.cloudant);
      });
    } else return cb(err, self.cloudant);
  });
};

/**
 * Return the driver instance, so cloudant can override this function,
 * and call driver functions as `this.getDriverInst().foo`
 */
Cloudant.prototype.getDriverInst = function() {
  return this.cloudant;
};

/**
  * Called by function CouchDB.prototype.selectModel, overriden by Cloudant
  */
Cloudant.prototype.getModelObjectSettings = function(mo) {
  if (mo) return mo.settings.cloudant;
  return undefined;
};

Cloudant.prototype.ping = function(cb) {
  debug('Cloudant.prototype.ping');
  const self = this;
  const driverInst = self.getDriverInst();
  if (driverInst) {
    driverInst.db.list(returnCB);
  } else {
    self.dataSource.once('connected', function(err) {
      if (err) cb(new Error('ping failed'));
      self.getDriverInst().db.list(returnCB);
    });
  }

  function returnCB(err, result) {
    debug('Cloudant.prototype.ping results %j %j', err, result);
    if (err) cb(new Error('ping failed'));
    else cb();
  }
};

/**
 * Exam a request's query and options to find the partition key.
 * From options: {partitionKey: 'US'}
 * From query: {selector: {partitionField: 'US'}}
 * The value from options should override the one from query
 *
 * @param {Object} mo The model object with properties consumed
 * by cloudant connector, generated by `CouchDB.prototype.selectModel`.
 * @param {Object} query The cloudant syntax query built from request query.
 * @param {Object} options The options from caller.
 */
Cloudant.prototype._getPartitionKey = function(mo, query, options) {
  const pkFromOption = options && options.partitionKey;
  debug('_getPartitionKey pkFromOption %s', pkFromOption);
  if (pkFromOption) return pkFromOption;

  const partitionField = mo.partitionKey;
  const pkFromQuery = partitionField &&
    query && query.selector && query.selector[partitionField];
  debug('_getPartitionKey pkFromQuery %s', pkFromQuery);
  return pkFromQuery;
};

/**
 *  Apply find queries function.
 *  This function will perform a partitionedFind if `partitionKey`
 *  is provided in the options or from the query(to be supported).
 *
 * @param {Object} mo The selected model
 * @param {Object} query The query to filter
 * @param {Object[]} docs Model document/data
 * @param {Object} include Include filter
 * @param {Object} options Options for find method, like `partitionKey`
 * @callback {Function} cb The callback function
 */
Cloudant.prototype._findRecursive = function(
  mo, query, docs, include, options, cb,
) {
  const self = this;
  const db = this.cloudant.use(self.getDbName(self));

  const partitionKey = self._getPartitionKey(mo, query, options);
  debug('Cloudant _findRecursive: partitionKey: %s', partitionKey);

  const findCb = function(err, rst) {
    debug('Cloudant.prototype.all (findRecursive) results: %j %j', err, rst);
    if (err) return cb(err);

    // only sort numeric id if the id type is of Number
    const idName = self.getIdName(mo.mo.model.modelName);
    if (!!idName && mo.mo.properties[idName].type.name === 'Number' &&
      query.sort)
      self._sortNumericId(rst.docs, query.sort);

    // work around for issue
    // https://github.com/strongloop/loopback-connector-Couchdb/issues/73
    if (!rst.docs) {
      const queryView = util.inspect(query, 4);
      debug('findRecursive query: %s', queryView);
      const errMsg = util.format('No documents returned for query: %s',
        queryView);
      return cb(new Error(g.f(errMsg)));
    }
    include(rst.docs, function(err) {
      if (err) return cb(err);
      self._extendDocs(rst, docs, query, mo, include, options, cb);
    });
  };

  if (partitionKey) {
    db.partitionedFind(partitionKey, query, findCb);
  } else {
    mo.db.find(query, findCb);
  }
};

// mixins
require('./view')(Cloudant);
require('./geo')(Cloudant);
require('./migrate')(Cloudant);
